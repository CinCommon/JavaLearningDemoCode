一、策略模式
介绍：

    分别封装行为接口，实现算法族，超类里放行为接口对象，在子类里具体设定行为对象。原则就是：分离变化部分，封装接口，基于接口变成各种功能。此模式让行为算法的变化独立于算法的使用者

二、示例
模拟鸭子项目，鸭子会嘎嘎叫，会游泳，有不同的颜色
1.传统模式
从面向对象的角度设计，封装鸭子的超类，扩展超类

[Duck](./Duck.java)

同理可有RedHeadDuck等集成Duck的父类

新增需求 —— 鸭子会飞


问题来了,这个Fly让所有子类都会飞了，这是不科学的，并不是所有的鸭子都会飞，且会飞的也飞的有快有慢。

继承的问题:对类的局部改动，尤其超类的局部改动，会影响其他部分。影响会有溢出效应。

因此只能通过子类中一个个去覆盖解决，较繁琐。
2.使用策略模式后
将行为改成接口 
    1、接口:
    
    // 飞行行为接口
    public interface FlyBehavior {
        void fly();
    }
    
    // 嘎嘎叫行为接口
    public interface QuackBehavior {
        void quack();
    }
2、好处:新增行为简单，行为类更好的复用，组合更方便。又有继承带来的复用好处
应对项目的拓展性，降低复杂度，分析项目变化与不变部分
提取变化部分，抽象成接口+实现
